<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whispers of the Canopy</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #080e16;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #gameCanvas {
            display: block;
            background: #080e16;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .preload-images {
            position: absolute;
            left: -9999px;
            width: 1px;
            height: 1px;
            opacity: 0;
        }
    </style>
</head>
<body>
    <!-- Preload images -->
    <div class="preload-images">
        <img id="runSprite" src="https://hc-cdn.hel1.your-objectstorage.com/s/v3/fd928ebfc670a318a63322ac90b412f8dcaa2543_run.png" alt="Run">
        <img id="attackSprite" src="https://hc-cdn.hel1.your-objectstorage.com/s/v3/57782f541c678455ea6b403a4f0e13480e024a97_attack.png" alt="Attack">
        <img id="hurtSprite" src="https://hc-cdn.hel1.your-objectstorage.com/s/v3/a3c1fc21b677cf5472802420c9c63b82667d245b_hurt.png" alt="Hurt">
        <img id="bushSprite" src="https://hc-cdn.hel1.your-objectstorage.com/s/v3/e9fe6733e0f1deac3c3744a76ba0448d6a701921_bush.png" alt="Bush">
        <img id="enemyWalkingSprite" src="https://hc-cdn.hel1.your-objectstorage.com/s/v3/6edbbbdf5c581fbc652ef04487dfbc481ac99eb3_enemywalking.png" alt="Enemy Walking">
        <img id="enemyDeathSprite" src="https://hc-cdn.hel1.your-objectstorage.com/s/v3/a4a994b7cd48d6ca388ef4ec7ad9b34b2cd7a6dd_enemydeath.png" alt="Enemy Death">
    </div>

    <canvas id="gameCanvas" width="1280" height="720"></canvas>

    <script>
        // === GAME CONSTANTS ===
        const GAME_WIDTH = 1280;
        const GAME_HEIGHT = 720;
        const LEVEL_WIDTH = 4200;
        const FPS = 60;
        const GRAVITY = 2400;
        const JUMP_FORCE = 900;
        const COYOTE_TIME = 0.14;
        const JUMP_BUFFER = 0.16;
        const WALK_SPEED = 240;
        const RUN_SPEED = 340;
        // Player constants
        const PLAYER_WIDTH = 42;
        const PLAYER_HEIGHT = 80;
        // Hitbox is smaller than the sprite for better gameplay
        const PLAYER_HITBOX_OFFSET_X = 6;  // Pixels from left/right
        const PLAYER_HITBOX_OFFSET_TOP = 10; // Pixels from top
        const PLAYER_HITBOX_OFFSET_BOTTOM = 4; // Pixels from bottom
        
        // Animation constants
        const RUN_FRAME_COUNT = 16;
        const ATTACK_FRAME_COUNT = 7;
        const HURT_FRAME_COUNT = 4;
        const RUN_ANIM_FPS = 18;
        const ATTACK_ANIM_FPS = 16;
        const HURT_ANIM_FPS = 8;
        const ATTACK_WIDTH = 110;
        const ATTACK_HEIGHT = 70;
        const ATTACK_COOLDOWN = 0.5;
        const ATTACK_ACTIVE_FRAME = 3;
        
        // Bush and enemy constants
        const BUSH_COLUMNS = 3;
        const BUSH_ROWS = 3;
        const ENEMY_TARGET_COUNT = 5;
        const ENEMY_WALKING_FRAME_COUNT = 9;
        const ENEMY_DEATH_FRAME_COUNT = 8;
        const ENEMY_WALK_ANIM_FPS = 12;
        const ENEMY_DEATH_ANIM_FPS = 10;
        const GUARD_WIDTH = 42;
        const GUARD_HEIGHT = 80;
        const DRONE_WIDTH = 48;
        const DRONE_HEIGHT = 48;
        
        // Orb constants
        const ORB_COUNT = 4;
        const ORB_SIZE = 20;
        const ORB_GLOW_SIZE = 35;
        const ORB_PULSE_SPEED = 3.0;

        // Colors
        const COLORS = {
            background: '#080e16',
            player: '#96e6ff',
            playerGlow: '#287c8c',
            enemy: '#282832',
            drone: '#506e82',
            stealth: '#3cc8b4',
            alert: '#dc5046',
            bush: '#235037',
            exit: '#3cc878',
            orb: '#b4dcff',
            orbGlow: '#64b4ff',
            orbCore: '#dcf0ff',
            platform: '#1e2823'
        };

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Input state
        const keys = {};
        let mouseClicked = false;

        // Sprite storage
        let runFrames = { right: [], left: [] };
        let attackFrames = { right: [], left: [] };
        let hurtFrames = { right: [], left: [] };
        let bushSprites = [];
        let enemyWalkingFrames = { right: [], left: [] };
        let enemyDeathFrames = { right: [], left: [] };

        // Game state
        let gameState = 'loading';
        let worldState = null;
        let tutorialCompleted = false;
        let stateTimer = 0;
        let lastTime = 0; // Will be initialized in game loop
        let spritesLoaded = 0;
        const totalSprites = 6;

        // === UTILITY CLASSES ===
        class SeededRandom {
            constructor(seed = Date.now()) {
                this.seed = seed;
            }
            
            random() {
                const x = Math.sin(this.seed++) * 10000;
                return x - Math.floor(x);
            }
            
            randint(min, max) {
                return Math.floor(this.random() * (max - min + 1)) + min;
            }
            
            choice(array) {
                return array[Math.floor(this.random() * array.length)];
            }
            
            uniform(min, max) {
                return min + this.random() * (max - min);
            }
        }

        // === SPRITE LOADING ===
        function extractFrames(image, frameCount, targetWidth, targetHeight, outputFrames) {
            if (!image || !image.complete) return;
            
            const frameWidth = image.width / frameCount;
            const frameHeight = image.height;
            
            for (let i = 0; i < frameCount; i++) {
                // Create right-facing frame
                const canvas = document.createElement('canvas');
                canvas.width = targetWidth;
                canvas.height = targetHeight;
                const ctx = canvas.getContext('2d');
                
                ctx.drawImage(
                    image,
                    i * frameWidth, 0, frameWidth, frameHeight,
                    0, 0, targetWidth, targetHeight
                );
                
                outputFrames.right.push(canvas);
                
                // Create left-facing frame (flipped)
                const flipped = document.createElement('canvas');
                flipped.width = targetWidth;
                flipped.height = targetHeight;
                const flipCtx = flipped.getContext('2d');
                flipCtx.translate(targetWidth, 0);
                flipCtx.scale(-1, 1);
                flipCtx.drawImage(canvas, 0, 0);
                
                outputFrames.left.push(flipped);
            }
        }

        function removeWhitePixels(canvas, tolerance = 4) {
            try {
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const threshold = 255 - tolerance;
                
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // If pixel is close to white, make it transparent
                    if (r >= threshold && g >= threshold && b >= threshold) {
                        data[i + 3] = 0; // Set alpha to 0
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
            } catch (e) {
                console.warn('Could not remove white pixels (CORS issue):', e.message);
                // Continue without removing white pixels
            }
            return canvas;
        }

        function extractBushSprites() {
            const bushImg = document.getElementById('bushSprite');
            if (!bushImg || !bushImg.complete) {
                console.warn('Bush sprite not ready for extraction');
                return;
            }
            
            console.log('Extracting bush sprites from image:', bushImg.naturalWidth, 'x', bushImg.naturalHeight);
            
            const tileWidth = bushImg.width / BUSH_COLUMNS;
            const tileHeight = bushImg.height / BUSH_ROWS;
            
            for (let row = 0; row < BUSH_ROWS; row++) {
                for (let col = 0; col < BUSH_COLUMNS; col++) {
                    const canvas = document.createElement('canvas');
                    canvas.width = tileWidth;
                    canvas.height = tileHeight;
                    const ctx = canvas.getContext('2d');
                    
                    ctx.drawImage(
                        bushImg,
                        col * tileWidth, row * tileHeight, tileWidth, tileHeight,
                        0, 0, tileWidth, tileHeight
                    );
                    
                    // Try to remove white pixels (may fail with CORS)
                    removeWhitePixels(canvas);
                    
                    bushSprites.push(canvas);
                }
            }
            
            console.log(`Extracted ${bushSprites.length} bush sprites`);
        }

        function checkSpriteLoaded() {
            spritesLoaded++;
            console.log(`Sprites loaded: ${spritesLoaded}/${totalSprites}`);
            
            if (spritesLoaded >= totalSprites) {
                console.log('All sprites loaded, extracting frames...');
                // Extract all frames (no bush sprites needed - using rectangles)
                extractFrames(document.getElementById('runSprite'), RUN_FRAME_COUNT, PLAYER_WIDTH, PLAYER_HEIGHT, runFrames);
                extractFrames(document.getElementById('attackSprite'), ATTACK_FRAME_COUNT, PLAYER_WIDTH, PLAYER_HEIGHT, attackFrames);
                extractFrames(document.getElementById('hurtSprite'), HURT_FRAME_COUNT, PLAYER_WIDTH, PLAYER_HEIGHT, hurtFrames);
                extractFrames(document.getElementById('enemyWalkingSprite'), ENEMY_WALKING_FRAME_COUNT, GUARD_WIDTH, GUARD_HEIGHT, enemyWalkingFrames);
                extractFrames(document.getElementById('enemyDeathSprite'), ENEMY_DEATH_FRAME_COUNT, GUARD_WIDTH, GUARD_HEIGHT, enemyDeathFrames);
                
                console.log('Frame extraction complete. Starting game...');
                gameState = 'title';
            }
        }

        function initSprites() {
            const spriteIds = ['runSprite', 'attackSprite', 'hurtSprite', 'bushSprite', 'enemyWalkingSprite', 'enemyDeathSprite'];
            
            console.log('Starting sprite loading...');
            
            spriteIds.forEach(id => {
                const img = document.getElementById(id);
                if (!img) {
                    console.error(`Image element not found: ${id}`);
                    return;
                }
                
                console.log(`Setting up ${id}:`, {
                    src: img.src,
                    complete: img.complete,
                    naturalWidth: img.naturalWidth,
                    naturalHeight: img.naturalHeight
                });
                
                img.onload = () => {
                    console.log(`✓ Loaded: ${id} (${img.naturalWidth}x${img.naturalHeight})`);
                    checkSpriteLoaded();
                };
                
                img.onerror = (e) => {
                    console.error(`✗ Failed to load sprite: ${id}`, e);
                    checkSpriteLoaded();
                };
                
                // If already complete, trigger check
                if (img.complete) {
                    if (img.naturalWidth > 0) {
                        console.log(`Already loaded: ${id}`);
                        setTimeout(checkSpriteLoaded, 10);
                    } else {
                        console.error(`Image failed to load (naturalWidth = 0): ${id}`);
                        setTimeout(checkSpriteLoaded, 10);
                    }
                }
            });
        }

        // === LEVEL GENERATION ===
        function makePlatforms(rng) {
            const platforms = [
                { x: 0, y: 640, width: LEVEL_WIDTH, height: 120 } // Floor
            ];

            let currentX = 140;
            let currentY = rng.randint(480, 560);
            const maxX = LEVEL_WIDTH - 420;

            while (currentX < maxX) {
                const width = rng.randint(170, 260);
                platforms.push({ x: currentX, y: currentY, width: width, height: 18 });
                const gap = rng.randint(90, 150);
                currentX += width + gap;
                currentY = Math.max(380, Math.min(600, currentY + rng.randint(-60, 60)));
            }

            // Landing platform near exit
            const landingWidth = 280;
            const landingY = Math.max(380, Math.min(580, currentY));
            const landingX = LEVEL_WIDTH - landingWidth - 120;
            platforms.push({ x: landingX, y: landingY, width: landingWidth, height: 18 });

            // Add some extra platforms above
            for (let i = 0; i < 3; i++) {
                const base = platforms[rng.randint(1, platforms.length - 1)];
                const width = rng.randint(130, 190);
                let x = base.x + base.width / 2 + rng.randint(-120, 120) - width / 2;
                x = Math.max(80, Math.min(LEVEL_WIDTH - width - 80, x));
                const y = Math.max(300, base.y - rng.randint(70, 130));
                platforms.push({ x, y, width, height: 18 });
            }

            return platforms;
        }

        function makeHidingSpots(rng, platforms) {
            const spots = [];
            const count = rng.randint(8, 12);

            // ONLY BUSHES (as per user request) - now using colored rectangles
            const bushTemplates = [
                { width: 110, height: 70, strength: 0.3 },
                { width: 120, height: 80, strength: 0.2 },
                { width: 140, height: 80, strength: 0.18 },
                { width: 150, height: 80, strength: 0.2 },
            ];

            for (let i = 0; i < count; i++) {
                const template = rng.choice(bushTemplates);
                const platform = rng.choice(platforms);
                
                let x, y;
                if (platform.width >= template.width + 20) {
                    const minX = platform.x + 5;
                    const maxX = platform.x + platform.width - template.width - 5;
                    x = rng.randint(Math.floor(minX), Math.floor(maxX));
                    y = platform.y - template.height;
                } else {
                    x = rng.randint(60, LEVEL_WIDTH - template.width - 60);
                    y = Math.min(rng.randint(520, 640 - template.height), 640 - template.height);
                }

                spots.push({
                    x, y,
                    width: template.width,
                    height: template.height,
                    strength: template.strength,
                    type: 'bush',
                    solid: false,
                    sprite: null // No sprites, use rectangles
                });
            }

            return spots;
        }

        function makeOrbs(rng, platforms) {
            const orbs = [];
            const perches = platforms.filter(p => p.height <= 20 && p.width > 40 && p.y <= 620);
            const validPerches = perches.length > 0 ? perches : [platforms[0]];
            let attempts = 0;

            while (orbs.length < ORB_COUNT && attempts < ORB_COUNT * 4) {
                attempts++;
                const platform = rng.choice(validPerches);
                const left = platform.x + 10;
                const right = platform.x + platform.width - 40;
                
                if (right <= left) continue;
                
                const x = rng.randint(left, right);
                const y = platform.y - ORB_SIZE - 5;
                
                orbs.push({
                    x, y,
                    width: ORB_SIZE * 2,
                    height: ORB_SIZE * 2,
                    rescued: false,
                    pulsePhase: rng.uniform(0, Math.PI * 2)
                });
            }

            return orbs;
        }

        function makeEnemies(rng, platforms) {
            const enemies = [];
            const perches = platforms.filter(p => p.height <= 20 && p.width > 80);
            let attempts = 0;

            while (enemies.length < ENEMY_TARGET_COUNT && attempts < ENEMY_TARGET_COUNT * 6) {
                attempts++;
                const isGuard = rng.random() < 0.65;

                let enemy;
                if (isGuard && perches.length > 0) {
                    const platform = rng.choice(perches);
                    const width = GUARD_WIDTH;
                    const height = GUARD_HEIGHT;
                    const roam = rng.randint(140, Math.min(420, platform.width + 200));
                    const pathLeft = Math.max(0, platform.x + platform.width / 2 - roam / 2);
                    const pathRight = Math.min(LEVEL_WIDTH, pathLeft + roam);
                    const maxPos = pathRight - width;
                    if (maxPos <= pathLeft) continue;
                    const x = Math.max(pathLeft, Math.min(platform.x, maxPos));
                    const y = platform.y - height;
                    
                    enemy = {
                        x, y, width, height,
                        pathLeft, pathRight,
                        speed: rng.randint(60, 110),
                        dir: rng.random() < 0.5 ? 1 : -1,
                        visionReach: rng.randint(260, 330),
                        visionSpread: rng.randint(150, 200),
                        type: 'guard',
                        active: true,
                        animTime: rng.uniform(0, 1.0 / ENEMY_WALK_ANIM_FPS),
                        animFrame: 0,
                        deathAnimTime: 0,
                        deathAnimFrame: 0
                    };
                } else {
                    const width = DRONE_WIDTH;
                    const height = DRONE_HEIGHT;
                    const x = rng.randint(100, LEVEL_WIDTH - width - 100);
                    const y = rng.randint(320, 460);
                    const roam = rng.randint(220, 420);
                    const pathLeft = Math.max(0, x - roam / 2);
                    const pathRight = Math.min(LEVEL_WIDTH, pathLeft + roam);
                    
                    enemy = {
                        x, y, width, height,
                        pathLeft, pathRight,
                        speed: rng.randint(110, 160),
                        dir: rng.random() < 0.5 ? 1 : -1,
                        visionReach: rng.randint(200, 280),
                        visionSpread: rng.randint(130, 180),
                        type: 'drone',
                        active: true,
                        animTime: rng.uniform(0, 1.0 / ENEMY_WALK_ANIM_FPS),
                        animFrame: 0,
                        deathAnimTime: 0,
                        deathAnimFrame: 0
                    };
                }

                enemies.push(enemy);
            }

            return enemies;
        }

        function makeTutorialLevel(rng) {
            const platforms = [
                { x: 0, y: 640, width: LEVEL_WIDTH, height: 120 },
                { x: 200, y: 560, width: 180, height: 18 },
                { x: 520, y: 520, width: 200, height: 18 },
                { x: 860, y: 500, width: 220, height: 18 },
                { x: 1180, y: 470, width: 220, height: 18 },
                { x: 1500, y: 520, width: 220, height: 18 },
            ];

            // ONLY BUSHES for tutorial - using colored rectangles
            const hidingSpots = [
                { x: 120, y: 580, width: 140, height: 70, strength: 0.25, type: 'bush', solid: false, sprite: null },
                { x: 460, y: 540, width: 150, height: 70, strength: 0.3, type: 'bush', solid: false, sprite: null },
                { x: 1020, y: 500, width: 150, height: 70, strength: 0.28, type: 'bush', solid: false, sprite: null },
            ];

            const orbs = [
                { x: 580, y: 460, width: ORB_SIZE * 2, height: ORB_SIZE * 2, rescued: false, pulsePhase: 0 },
                { x: 1250, y: 410, width: ORB_SIZE * 2, height: ORB_SIZE * 2, rescued: false, pulsePhase: Math.PI },
            ];

            const enemies = [
                {
                    x: 900, y: 440, width: GUARD_WIDTH, height: GUARD_HEIGHT,
                    pathLeft: 850, pathRight: 1150,
                    speed: 70, dir: 1,
                    visionReach: 260, visionSpread: 150,
                    type: 'guard', active: true,
                    animTime: 0, animFrame: 0,
                    deathAnimTime: 0, deathAnimFrame: 0
                }
            ];

            return {
                platforms,
                hidingSpots,
                orbs,
                enemies,
                exitRect: { x: 1650, y: 380, width: 90, height: 220 },
                tutorialHints: [
                    { text: "Use A/D to move and SPACE to jump", x: 50, y: 90 },
                    { text: "Press S to crouch in bushes to stay hidden", x: 320, y: 180 },
                    { text: "Collect the glowing orbs, then head to the exit", x: 520, y: 120 },
                    { text: "Left click to attack if you need to fight", x: 760, y: 60 },
                ]
            };
        }

        function resetWorld(seed = null, tutorial = false) {
            const rng = new SeededRandom(seed || Date.now());
            
            let levelData;
            if (tutorial) {
                levelData = makeTutorialLevel(rng);
            } else {
                const platforms = makePlatforms(rng);
                const hidingSpots = makeHidingSpots(rng, platforms);
                const orbs = makeOrbs(rng, platforms);
                const enemies = makeEnemies(rng, platforms);
                
                levelData = {
                    platforms,
                    hidingSpots,
                    orbs,
                    enemies,
                    exitRect: { x: LEVEL_WIDTH - 160, y: 420, width: 90, height: 220 },
                    tutorialHints: []
                };
            }

            return {
                playerX: 80,
                playerY: 640 - PLAYER_HEIGHT,
                playerVelX: 0,
                playerVelY: 0,
                facing: 1,
                onGround: false,
                coyoteTimer: 0,
                jumpBuffer: 0,
                animFrame: 0,
                animTime: 0,
                attacking: false,
                attackCooldown: 0,
                attackAnimFrame: 0,
                attackAnimTime: 0,
                attackRect: null,
                
                platforms: levelData.platforms,
                hidingSpots: levelData.hidingSpots,
                orbs: levelData.orbs,
                enemies: levelData.enemies,
                exitRect: levelData.exitRect,
                tutorialHints: levelData.tutorialHints,
                
                visibility: 35,
                alertMeter: 0,
                rescued: 0,
                cameraX: 0,
                caught: false,
                win: false,
                flashAmount: 0,
                particles: [],
                isTutorial: tutorial
            };
        }

        // === COLLISION AND GEOMETRY ===
        function rectCollides(r1, r2) {
            return r1.x < r2.x + r2.width &&
                   r1.x + r1.width > r2.x &&
                   r1.y < r2.y + r2.height &&
                   r1.y + r1.height > r2.y;
        }

        function buildVisionCone(enemy) {
            const facing = enemy.dir >= 0 ? 1 : -1;
            const eyeX = enemy.x + enemy.width / 2;
            const eyeY = enemy.type === 'guard' ? enemy.y + 20 : enemy.y + enemy.height / 2;
            const reach = enemy.visionReach;
            const spread = enemy.visionSpread;
            
            const tip = [eyeX + facing * reach, eyeY - 30];
            const upper = [eyeX + facing * reach * 0.6, eyeY - spread * 0.4];
            const lower = [eyeX + facing * reach * 0.6, eyeY + spread * 0.4];
            
            return [[eyeX, eyeY], upper, tip, lower];
        }

        function pointInPoly(point, polygon) {
            const [px, py] = point;
            let inside = false;
            let j = polygon.length - 1;
            
            for (let i = 0; i < polygon.length; i++) {
                const [ix, iy] = polygon[i];
                const [jx, jy] = polygon[j];
                const intersect = ((iy > py) !== (jy > py)) &&
                    (px < (jx - ix) * (py - iy) / (jy - iy + 0.0001) + ix);
                if (intersect) inside = !inside;
                j = i;
            }
            
            return inside;
        }

        function getPlayerHitbox(x, y) {
            return {
                x: x + PLAYER_HITBOX_OFFSET_X,
                y: y + PLAYER_HITBOX_OFFSET_TOP,
                width: PLAYER_WIDTH - (PLAYER_HITBOX_OFFSET_X * 2),
                height: PLAYER_HEIGHT - PLAYER_HITBOX_OFFSET_TOP - PLAYER_HITBOX_OFFSET_BOTTOM
            };
        }

        // PARTICLE SYSTEM =
        function spawnParticles(world, x, y) {
            for (let i = 0; i < 8; i++) {
                const angle = Math.random() * Math.PI * 2;
                world.particles.push({
                    x: x,
                    y: y,
                    dx: Math.cos(angle),
                    dy: Math.sin(angle),
                    life: 0.4 + Math.random() * 0.4
                });
            }
        }

        function updateParticles(world, dt) {
            for (let p of world.particles) {
                p.x += p.dx * 60 * dt;
                p.y += p.dy * 60 * dt;
                p.life -= dt;
            }
            world.particles = world.particles.filter(p => p.life > 0);
        }

        // === GAME UPDATE ===
        function updatePlayState(world, dt) {
            // Input handling
            world.jumpBuffer = Math.max(0, world.jumpBuffer - dt);
            world.coyoteTimer = Math.max(0, world.coyoteTimer - dt);
            world.attackCooldown = Math.max(0, world.attackCooldown - dt);
            world.attackRect = null;

            let moveDir = 0;
            if (keys['a'] || keys['ArrowLeft']) moveDir -= 1;
            if (keys['d'] || keys['ArrowRight']) moveDir += 1;
            const crouching = keys['s'] || keys['ArrowDown'];
            const running = keys['shift'];

            // Movement
            let moveSpeed = running ? RUN_SPEED : WALK_SPEED;
            if (crouching) moveSpeed *= 0.6;
            
            // Directly set velocity based on input
            if (moveDir !== 0) {
                world.playerVelX = moveDir * moveSpeed;
                world.facing = moveDir > 0 ? 1 : -1;
            } else {
                // Stop immediately when no input
                world.playerVelX = 0;
            }

            // Jump
            if (world.jumpBuffer > 0 && (world.onGround || world.coyoteTimer > 0)) {
                world.playerVelY = -JUMP_FORCE;
                world.onGround = false;
                world.coyoteTimer = 0;
                world.jumpBuffer = 0;
            }

            // Gravity
            world.playerVelY += GRAVITY * dt;

            // Horizontal collision
            world.playerX += world.playerVelX * dt;
            playerRect = getPlayerHitbox(world.playerX, world.playerY);
            
            for (let platform of world.platforms) {
                if (rectCollides(playerRect, platform)) {
                    if (world.playerVelX > 0) {
                        // Moving right, hit left side of platform
                        world.playerX = platform.x - PLAYER_WIDTH;
                    } else if (world.playerVelX < 0) {
                        // Moving left, hit right side of platform
                        world.playerX = platform.x + platform.width;
                    }
                    // Update playerRect after position change
                    playerRect = getPlayerHitbox(world.playerX, world.playerY);
                }
            }

            // Vertical collision
            world.playerY += world.playerVelY * dt;
            playerRect = getPlayerHitbox(world.playerX, world.playerY);
            world.onGround = false;

            for (let platform of world.platforms) {
                if (rectCollides(playerRect, platform)) {
                    if (world.playerVelY > 0) {
                        // Land on top of platform
                        world.playerY = platform.y - PLAYER_HEIGHT;
                        world.onGround = true;
                        world.playerVelY = 0;
                    } else if (world.playerVelY < 0) {
                        // Hit bottom of platform
                        world.playerY = platform.y + platform.height - PLAYER_HITBOX_OFFSET_TOP;
                        world.playerVelY = 0;
                    }
                    // Update playerRect after position change
                    playerRect = getPlayerHitbox(world.playerX, world.playerY);
                }
            }

            if (world.onGround) world.coyoteTimer = COYOTE_TIME;

            // Attack state is now handled directly in the mousedown event

            // === ANIMATION STATE MACHINE ===
            // Smooth movement detection with some threshold
            const moving = Math.abs(world.playerVelX) > 10; // Reduced threshold for smoother transitions
            
            // Store previous positions for interpolation
            world.prevPlayerX = world.prevPlayerX || world.playerX;
            world.prevPlayerY = world.prevPlayerY || world.playerY;
            
            // Handle attack cooldown
            if (world.attackCooldown > 0) {
                world.attackCooldown -= dt;
            }

            // Animation state priority: Hurt > Attack > Run > Idle
            if (world.hurt) {
                // Hurt animation - play once then return to previous state
                world.hurtTime += dt;
                const frameFloat = world.hurtTime * HURT_ANIM_FPS;
                world.hurtFrame = Math.min(
                    Math.floor(frameFloat),
                    hurtFrames.right.length - 1
                );
                
                if (world.hurtTime >= (hurtFrames.right.length / HURT_ANIM_FPS)) {
                    world.hurt = false;
                    world.hurtTime = 0;
                    world.hurtFrame = 0;
                }
            } 
            else if (world.attacking) {
                // Attack animation - play once then return to idle/run
                const totalFrames = 7;
                const attackDuration = totalFrames / ATTACK_ANIM_FPS;
                
                world.attackAnimTime += dt;
                const attackFrameFloat = (world.attackAnimTime / attackDuration) * totalFrames;
                world.attackAnimFrame = Math.min(
                    Math.floor(attackFrameFloat),
                    totalFrames - 1
                );
                
                // End attack when animation completes
                if (world.attackAnimTime >= attackDuration) {
                    world.attacking = false;
                    world.attackAnimTime = 0;
                    world.attackAnimFrame = 0;
                    world.attackRect = null;
                }
            } 
            else if (moving) {
                // Running animation - use floating point for smoother animation
                world.animTime += dt;
                const frameFloat = world.animTime * RUN_ANIM_FPS;
                world.animFrame = Math.floor(frameFloat) % runFrames.right.length;
                
                // Store animation progress for interpolation
                world.animProgress = frameFloat % 1;
            } 
            else {
                // Idle - first frame of running animation
                world.animTime = 0;
                world.animFrame = 0;
                world.animProgress = 0;
            }
            
            // Store previous positions for interpolation
            world.prevPlayerX = world.playerX;
            world.prevPlayerY = world.playerY;

            // Stealth logic - ONLY BUSHES work for hiding
            let playerHidden = false;
            let hidingStrength = 1.0;
            
            for (let spot of world.hidingSpots) {
                if (spot.type === 'bush' && rectCollides(playerRect, spot)) {
                    playerHidden = true;
                    hidingStrength = Math.min(hidingStrength, spot.strength);
                }
            }

            let targetVisibility = 85;
            if (crouching) targetVisibility = 60;
            if (playerHidden) targetVisibility = 20 + 60 * hidingStrength;

            const speedBonus = Math.min(Math.abs(world.playerVelX) / RUN_SPEED * 30, 30);
            if (!world.onGround) targetVisibility += 10;
            if (moveDir === 0) targetVisibility += speedBonus * 0.4;
            else targetVisibility += speedBonus;

            world.visibility += (targetVisibility - world.visibility) * 4 * dt;
            world.visibility = Math.max(5, Math.min(100, world.visibility));

            // Camera
            const cameraGoal = world.playerX + PLAYER_WIDTH / 2 - GAME_WIDTH / 2;
            world.cameraX += (Math.max(0, Math.min(LEVEL_WIDTH - GAME_WIDTH, cameraGoal)) - world.cameraX) * 2.5 * dt;

            // Attack collision
            const attackActive = world.attacking && world.attackAnimFrame >= ATTACK_ACTIVE_FRAME;
            if (attackActive) {
                const slashRect = {
                    x: world.playerX + world.facing * (PLAYER_WIDTH / 2 + ATTACK_WIDTH / 2) - ATTACK_WIDTH / 2,
                    y: world.playerY + PLAYER_HEIGHT / 2 - ATTACK_HEIGHT / 2,
                    width: ATTACK_WIDTH,
                    height: ATTACK_HEIGHT
                };
                world.attackRect = slashRect;

                for (let enemy of world.enemies) {
                    if (enemy.active && rectCollides(slashRect, enemy)) {
                        enemy.active = false;
                        spawnParticles(world, enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                    }
                }
            }

            // Enemy AI and detection
            let spotted = false;
            const playerCenter = [world.playerX + PLAYER_WIDTH / 2, world.playerY + PLAYER_HEIGHT / 2];

            for (let enemy of world.enemies) {
                if (!enemy.active) {
                    // Update death animation
                    enemy.deathAnimTime += dt;
                    enemy.deathAnimFrame = Math.min(
                        Math.floor(enemy.deathAnimTime * ENEMY_DEATH_ANIM_FPS),
                        ENEMY_DEATH_FRAME_COUNT - 1
                    );
                    continue;
                }

                // Update walking animation
                enemy.animTime += dt;
                enemy.animFrame = Math.floor(enemy.animTime * ENEMY_WALK_ANIM_FPS) % ENEMY_WALKING_FRAME_COUNT;

                // Movement
                enemy.x += enemy.speed * enemy.dir * dt;
                if (enemy.x < enemy.pathLeft || enemy.x + enemy.width > enemy.pathRight) {
                    enemy.dir *= -1;
                    enemy.x = Math.max(enemy.pathLeft, Math.min(enemy.x, enemy.pathRight - enemy.width));
                }

                // Vision cone detection
                const cone = buildVisionCone(enemy);
                const inside = pointInPoly(playerCenter, cone);
                let detectionRate = 0;

                if (inside) {
                    if (!playerHidden) {
                        world.caught = true;
                        world.flashAmount = 1.0;
                        spotted = true;
                        break;
                    }
                    const visibilityFactor = world.visibility / 100;
                    detectionRate += 30 * visibilityFactor * 0.4;
                    if (crouching) detectionRate *= 0.6;
                }

                // Sound detection
                const distance = Math.hypot(
                    enemy.x + enemy.width / 2 - playerCenter[0],
                    enemy.y + enemy.height / 2 - playerCenter[1]
                );
                if (Math.abs(world.playerVelX) > WALK_SPEED * 0.9 && distance < 220) {
                    detectionRate += 20;
                }

                if (detectionRate > 0) spotted = true;
                world.alertMeter += detectionRate * dt;
            }

            // Alert meter management
            if (world.caught) {
                world.alertMeter = 100;
            } else {
                if (!spotted) {
                    world.alertMeter = Math.max(0, world.alertMeter - 25 * dt);
                }
                world.alertMeter = Math.min(120, world.alertMeter);
                if (world.alertMeter >= 100) {
                    world.caught = true;
                    world.flashAmount = 1.0;
                }
            }

            // Orb collection
            if (!world.caught) {
                for (let orb of world.orbs) {
                    if (!orb.rescued && rectCollides(playerRect, orb)) {
                        orb.rescued = true;
                        world.rescued++;
                        spawnParticles(world, orb.x + orb.width / 2, orb.y + orb.height / 2);
                    }
                }
            }

            updateParticles(world, dt);

            // Win condition
            if (!world.caught && world.rescued === world.orbs.length && rectCollides(playerRect, world.exitRect)) {
                world.win = true;
            }

            world.flashAmount = Math.max(0, world.flashAmount - dt);
        }

        // === RENDERING ===
        function drawBackground(cameraX) {
            ctx.fillStyle = COLORS.background;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            // Parallax layers
            for (let layer = 0; layer < 3; layer++) {
                const layerColor = `rgb(${10 + layer * 10}, ${25 + layer * 20}, ${20 + layer * 10})`;
                const offset = cameraX * (0.15 * layer);
                
                for (let x = -200; x < LEVEL_WIDTH; x += 220) {
                    const trunkX = x - offset;
                    ctx.fillStyle = layerColor;
                    ctx.fillRect(trunkX - cameraX, 260 + layer * 60, 30, 460);
                }
            }
        }

        function drawOrb(orb, cam, currentTime) {
            if (orb.rescued) return;
            
            const centerX = orb.x + orb.width / 2 - cam;
            const centerY = orb.y + orb.height / 2;
            
            // Pulse effect
            const pulse = 0.5 + 0.5 * Math.sin(currentTime * ORB_PULSE_SPEED + orb.pulsePhase);
            const currentGlowSize = ORB_GLOW_SIZE * (0.8 + 0.2 * pulse);
            const currentOrbSize = ORB_SIZE * (0.9 + 0.1 * pulse);
            
            // Draw outer glow (multiple layers)
            for (let i = 3; i > 0; i--) {
                const radius = currentGlowSize * (i / 3);
                const alpha = (80 + 40 * pulse) * (i / 3) * 0.6 / 255;
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fillStyle = COLORS.orbGlow + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                ctx.fill();
            }
            
            // Draw orb core
            ctx.beginPath();
            ctx.arc(centerX, centerY, Math.max(3, currentOrbSize * 0.6), 0, Math.PI * 2);
            ctx.fillStyle = COLORS.orbCore;
            ctx.fill();
            
            // Draw orb outer ring
            ctx.beginPath();
            ctx.arc(centerX, centerY, currentOrbSize, 0, Math.PI * 2);
            ctx.strokeStyle = COLORS.orb;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw arrow marker above orb
            const markerY = centerY - currentGlowSize * 0.7 - 20;
            const markerAlpha = (180 + 75 * pulse) / 255;
            
            ctx.fillStyle = COLORS.orbGlow + Math.floor(markerAlpha * 255).toString(16).padStart(2, '0');
            ctx.beginPath();
            ctx.moveTo(centerX, markerY - 10);
            ctx.lineTo(centerX - 6, markerY - 2);
            ctx.lineTo(centerX + 6, markerY - 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(centerX, markerY + 2, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawGame(world) {
            drawBackground(world.cameraX);
            const cam = world.cameraX;

            // Draw platforms
            ctx.fillStyle = COLORS.platform;
            for (let platform of world.platforms) {
                ctx.fillRect(platform.x - cam, platform.y, platform.width, platform.height);
            }

            // Draw hiding spots as colored rectangles
            for (let spot of world.hidingSpots) {
                // Determine color based on type
                if (spot.type === 'bush') {
                    ctx.fillStyle = '#2d8659'; // Green for bushes
                } else if (spot.type === 'rock' || spot.type === 'cave') {
                    ctx.fillStyle = '#5a6a78'; // Grey for rocks
                } else if (spot.type === 'log') {
                    ctx.fillStyle = '#5c4a33'; // Brown for logs
                } else {
                    ctx.fillStyle = COLORS.bush; // Default
                }
                
                // Draw rounded rectangle for better appearance
                ctx.beginPath();
                const radius = 8;
                ctx.roundRect(spot.x - cam, spot.y, spot.width, spot.height, radius);
                ctx.fill();
            }

            // Draw exit
            ctx.fillStyle = COLORS.exit;
            ctx.fillRect(world.exitRect.x - cam, world.exitRect.y, world.exitRect.width, world.exitRect.height);

            // Draw enemies and vision cones
            for (let enemy of world.enemies) {
                // Draw vision cone for active enemies
                if (enemy.active) {
                    const cone = buildVisionCone(enemy);
                    const conePoints = cone.map(([x, y]) => [x - cam, y]);
                    
                    ctx.fillStyle = enemy.type === 'guard' ? 
                        'rgba(255, 210, 90, 0.23)' : 
                        'rgba(120, 200, 255, 0.23)';
                    ctx.beginPath();
                    conePoints.forEach(([x, y], i) => {
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    });
                    ctx.closePath();
                    ctx.fill();
                }

                // Draw enemy sprite or rectangle
                let spriteDrawn = false;
                
                if (!enemy.active && enemyDeathFrames.right.length > 0) {
                    // Death animation
                    const orientation = enemy.dir >= 0 ? 'right' : 'left';
                    const frames = enemyDeathFrames[orientation];
                    if (frames && frames.length > 0) {
                        const frame = frames[Math.min(enemy.deathAnimFrame, frames.length - 1)];
                        ctx.drawImage(frame, enemy.x - cam, enemy.y);
                        spriteDrawn = true;
                    }
                } else if (enemy.active && enemy.type === 'guard' && enemyWalkingFrames.right.length > 0) {
                    // Walking animation for guards
                    const orientation = enemy.dir >= 0 ? 'right' : 'left';
                    const frames = enemyWalkingFrames[orientation];
                    if (frames && frames.length > 0) {
                        const frame = frames[enemy.animFrame % frames.length];
                        ctx.drawImage(frame, enemy.x - cam, enemy.y);
                        spriteDrawn = true;
                    }
                }
                
                // Fallback to rectangle
                if (!spriteDrawn) {
                    const color = enemy.type === 'guard' ? COLORS.enemy : COLORS.drone;
                    ctx.fillStyle = enemy.active ? color : color + '99';
                    ctx.fillRect(enemy.x - cam, enemy.y, enemy.width, enemy.height);
                }
            }

            // Draw orbs
            const currentTime = performance.now() / 1000;
            for (let orb of world.orbs) {
                drawOrb(orb, cam, currentTime);
            }

            // Draw player
            let spriteDrawn = false;
            const orientation = world.facing >= 0 ? 'right' : 'left';
            
            if (world.caught && hurtFrames.right.length > 0) {
                const frames = hurtFrames[orientation];
                const animIndex = Math.floor((performance.now() * HURT_ANIM_FPS / 1000)) % frames.length;
                ctx.drawImage(frames[animIndex], world.playerX - cam, world.playerY);
                spriteDrawn = true;
            } else if (world.attacking && attackFrames.right.length > 0) {
                const frames = attackFrames[orientation];
                const idx = Math.min(world.attackAnimFrame, frames.length - 1);
                ctx.drawImage(frames[idx], world.playerX - cam, world.playerY);
                spriteDrawn = true;
            } else if (runFrames.right.length > 0) {
                const frames = runFrames[orientation];
                const frame = frames[world.animFrame % frames.length];
                ctx.drawImage(frame, world.playerX - cam, world.playerY);
                spriteDrawn = true;
            }
            
            if (!spriteDrawn) {
                ctx.fillStyle = COLORS.player;
                ctx.fillRect(world.playerX - cam, world.playerY, PLAYER_WIDTH, PLAYER_HEIGHT);
            }

            // Draw particles
            for (let p of world.particles) {
                const alpha = p.life;
                ctx.fillStyle = COLORS.orbGlow + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                ctx.beginPath();
                ctx.arc(p.x - cam, p.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw UI
            // Stealth bar
            ctx.fillStyle = '#28323c';
            ctx.fillRect(30, 30, 280, 22);
            ctx.fillStyle = COLORS.stealth;
            ctx.fillRect(30, 30, 280 * (world.visibility / 100), 22);
            ctx.strokeStyle = '#c8c8c8';
            ctx.lineWidth = 2;
            ctx.strokeRect(30, 30, 280, 22);

            // Alert bar
            ctx.fillStyle = '#281e1e';
            ctx.fillRect(GAME_WIDTH - 340, 30, 300, 20);
            ctx.fillStyle = COLORS.alert;
            ctx.fillRect(GAME_WIDTH - 340, 30, 300 * (world.alertMeter / 100), 20);
            ctx.strokeStyle = '#c8c8c8';
            ctx.lineWidth = 2;
            ctx.strokeRect(GAME_WIDTH - 340, 30, 300, 20);

            // Orbs collected text
            ctx.fillStyle = '#dce6e6';
            ctx.font = '26px Arial';
            ctx.fillText(`Orbs: ${world.rescued}/${world.orbs.length}`, 30, 65);

            // Controls hint
            ctx.fillStyle = '#aab4be';
            ctx.font = '20px Arial';
            ctx.fillText("A/D move | SPACE jump | S hide | Click attack | R retry", 30, GAME_HEIGHT - 20);

            // Alert warning overlay
            if (world.alertMeter > 85) {
                ctx.fillStyle = 'rgba(200, 50, 50, 0.2)';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            }

            // Flash effect
            if (world.flashAmount > 0) {
                ctx.fillStyle = `rgba(255, 80, 80, ${0.47 * world.flashAmount})`;
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            }

            // Tutorial hints
            if (world.isTutorial) {
                for (let hint of world.tutorialHints) {
                    ctx.font = '20px Arial';
                    const textWidth = ctx.measureText(hint.text).width;
                    
                    ctx.fillStyle = '#0f1923';
                    ctx.fillRect(hint.x - 8, hint.y - 8, textWidth + 16, 36);
                    
                    ctx.fillStyle = '#f0f0f0';
                    ctx.fillText(hint.text, hint.x, hint.y + 12);
                }
            }
        }

        function drawTitle() {
            drawBackground(0);
            
            ctx.fillStyle = '#dce6e6';
            ctx.font = '54px Arial';
            const titleText = "Whispers of the Canopy";
            const titleWidth = ctx.measureText(titleText).width;
            ctx.fillText(titleText, GAME_WIDTH / 2 - titleWidth / 2, GAME_HEIGHT / 2 - 80);
            
            ctx.font = '26px Arial';
            const promptText = "Press ENTER to start";
            const promptWidth = ctx.measureText(promptText).width;
            ctx.fillText(promptText, GAME_WIDTH / 2 - promptWidth / 2, GAME_HEIGHT / 2);
        }

        function drawCaught() {
            ctx.fillStyle = '#f07878';
            ctx.font = '54px Arial';
            const caughtText = "Caught!";
            const caughtWidth = ctx.measureText(caughtText).width;
            ctx.fillText(caughtText, GAME_WIDTH / 2 - caughtWidth / 2, GAME_HEIGHT / 2 - 60);
            
            ctx.font = '26px Arial';
            const promptText = "Press R to retry";
            const promptWidth = ctx.measureText(promptText).width;
            ctx.fillText(promptText, GAME_WIDTH / 2 - promptWidth / 2, GAME_HEIGHT / 2);
        }

        function drawWin(world) {
            const winText = world && world.isTutorial ? 
                "Tutorial complete!" : 
                "The forest is safe... for now";
            const promptText = world && world.isTutorial ? 
                "Press ENTER to begin the real mission" : 
                "Press ENTER to play again";
            
            ctx.fillStyle = '#c8ffc8';
            ctx.font = '54px Arial';
            const winWidth = ctx.measureText(winText).width;
            ctx.fillText(winText, GAME_WIDTH / 2 - winWidth / 2, GAME_HEIGHT / 2 - 60);
            
            ctx.font = '26px Arial';
            const promptWidth = ctx.measureText(promptText).width;
            ctx.fillText(promptText, GAME_WIDTH / 2 - promptWidth / 2, GAME_HEIGHT / 2);
        }

        function drawLoading() {
            ctx.fillStyle = COLORS.background;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 36px Arial';
            const loadingText = `Loading Sprites... ${spritesLoaded}/${totalSprites}`;
            const textWidth = ctx.measureText(loadingText).width;
            ctx.fillText(loadingText, GAME_WIDTH / 2 - textWidth / 2, GAME_HEIGHT / 2);
            
            // Draw loading bar
            const barWidth = 400;
            const barHeight = 30;
            const barX = GAME_WIDTH / 2 - barWidth / 2;
            const barY = GAME_HEIGHT / 2 + 40;
            
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
            
            ctx.fillStyle = COLORS.stealth;
            const progress = spritesLoaded / totalSprites;
            ctx.fillRect(barX + 2, barY + 2, (barWidth - 4) * progress, barHeight - 4);
        }

        // === EVENT HANDLERS ===
        document.addEventListener('keydown', (e) => {
            // Normalize key to lowercase for consistency
            const key = e.key.toLowerCase();
            keys[key] = true;
            keys[e.key] = true; // Also store original case

            // Prevent default for game controls
            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', ' ', 'a', 'd', 's', 'w'].includes(e.key)) {
                e.preventDefault();
            }

            if (gameState === 'title' && e.key === 'Enter') {
                worldState = resetWorld(null, !tutorialCompleted);
                gameState = 'playing';
                stateTimer = 0;
            } else if (gameState === 'playing' && e.key === ' ') {
                if (worldState) {
                    worldState.jumpBuffer = JUMP_BUFFER;
                }
            } else if (gameState === 'caught' && (e.key === 'r' || e.key === 'R')) {
                worldState = resetWorld(null, worldState ? worldState.isTutorial : false);
                gameState = 'playing';
                stateTimer = 0;
            } else if (gameState === 'win' && e.key === 'Enter') {
                if (worldState && worldState.isTutorial && !tutorialCompleted) {
                    tutorialCompleted = true;
                    worldState = resetWorld();
                } else {
                    worldState = resetWorld(null, !tutorialCompleted);
                }
                gameState = 'playing';
                stateTimer = 0;
            }
        });

        document.addEventListener('keyup', (e) => {
            // Clear both lowercase and original case
            const key = e.key.toLowerCase();
            keys[key] = false;
            keys[e.key] = false;
        });

        // Track mouse button state
        let mouseDown = false;
        
        // Handle mouse down for attacking
        // Track if we've already processed a click in this frame
        let clickProcessed = false;
        
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) { // Only left mouse button
                mouseDown = true;
                
                if (gameState === 'playing' && !clickProcessed) {
                    if (!worldState.attacking && worldState.attackCooldown <= 0) {
                        worldState.attacking = true;
                        worldState.attackCooldown = ATTACK_COOLDOWN;
                        worldState.attackAnimTime = 0;
                        worldState.attackAnimFrame = 0;
                        clickProcessed = true; // Prevent multiple attacks from the same click
                    }
                } else if (gameState === 'title') {
                    // Start game on title screen click
                    worldState = resetWorld(null, !tutorialCompleted);
                    gameState = 'playing';
                    stateTimer = 0;
                }
            }
        });
        
        // Handle mouse up to reset the attack state
        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                mouseDown = false;
                clickProcessed = false; // allow a new attack on the next click
            }
        });
        
        // Handle mouse leave to prevent stuck states
        canvas.addEventListener('mouseleave', () => {
            mouseDown = false;
            clickProcessed = false; // reset when leaving canvas to avoid stuck state
        });
        
        // Remove the old click handler since we're handling everything in mousedown now

        // === GAME LOOP ===
        let accumulator = 0;
        const timeStep = 1/60; // Fixed timestep for 60 FPS
        lastTime = performance.now(); // Initialize lastTime
        
        function gameLoop(currentTime) {
            // Calculate delta time and cap it
            let dt = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            // Prevent spiral of death
            dt = Math.min(dt, 0.25);
            
            // Add to accumulator
            accumulator += dt;
            
            // Fixed timestep updates
            while (accumulator >= timeStep) {
                updateGame(timeStep);
                accumulator -= timeStep;
            }
            
            // Render at full framerate
            render();
            
            requestAnimationFrame(gameLoop);
        }
        
        function updateGame(dt) {
            // Update game state
            if (gameState === 'loading') {
                // No updates during loading
            } else if (gameState === 'title') {
                // No updates on title screen
            } else if (gameState === 'playing') {
                if (worldState) {
                    updatePlayState(worldState, dt);
                    
                    if (worldState.caught) {
                        gameState = 'caught';
                        stateTimer = 0;
                    }
                    if (worldState.win) {
                        gameState = 'win';
                        stateTimer = 0;
                    }
                }
            } else if (gameState === 'caught') {
                stateTimer += dt;
                if (stateTimer >= 1.8) {
                    worldState = resetWorld(null, worldState ? worldState.isTutorial : false);
                    gameState = 'playing';
                    stateTimer = 0;
                }
            }
        }
        
        function render() {
            // Clear the canvas with a single operation
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Render appropriate screen
            if (gameState === 'loading') {
                drawLoading();
            } else if (gameState === 'title') {
                drawTitle();
            } else if (gameState === 'playing' || gameState === 'caught' || gameState === 'win') {
                if (worldState) {
                    // Enable image smoothing for smoother rendering
                    ctx.imageSmoothingEnabled = true;
                    ctx.webkitImageSmoothingEnabled = true;
                    ctx.mozImageSmoothingEnabled = true;
                    
                    // Render the game with interpolation
                    drawGame(worldState);
                    
                    if (gameState === 'caught') {
                        drawCaught();
                    } else if (gameState === 'win') {
                        drawWin(worldState);
                    }
                }
            }
        }

        // === INITIALIZATION ===
        // Wait for DOM to be fully loaded
        window.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing game...');
            console.log('Canvas:', canvas);
            console.log('Context:', ctx);
            
            initSprites();
            
            // Fallback: Force start after 5 seconds if loading fails
            setTimeout(() => {
                if (gameState === 'loading') {
                    console.warn('Sprite loading timeout - forcing game start');
                    gameState = 'title';
                }
            }, 5000);
            
            // Start game loop
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        });
    </script>
</body>
</html>
